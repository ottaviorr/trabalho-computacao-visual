<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js - Target Practice</title>
        <meta charset=utf-8 />
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
        
        <style>
            body { margin: 0; }
            .overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-family: monospace;
                text-align: center;
                background-color: rgba(0, 0, 0, 0.8);
                padding: 40px;
                border-radius: 10px;
                z-index: 101;
                width: 80%;
                max-width: 500px;
            }
            .overlay h1 { font-size: 48px; margin-bottom: 20px; }
            .overlay p { font-size: 22px; margin-bottom: 30px; }
            .overlay button {
                font-size: 24px;
                padding: 10px 20px;
                cursor: pointer;
                margin: 5px;
            }
            #hud {
                position: absolute;
                top: 10px;
                left: 10px;
                color: white;
                font-family: monospace;
                font-size: 24px;
                background-color: rgba(0, 0, 0, 0.5);
                padding: 10px;
                border-radius: 5px;
                z-index: 100;
                display: none;
            }
            #startMenu { display: flex; flex-direction: column; align-items: center; }
            #endScreen { display: none; }

            #crosshair {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 24px;
                font-weight: bold;
                font-family: monospace;
                pointer-events: none;
                z-index: 100;
                display: none;
            }
            #startMenu button {
                transition: background-color 0.2s, border-color 0.2s, opacity 0.2s;
                border: 2px solid white;
                background-color: transparent;
                color: white;
            }
            #startMenu button:hover:not(:disabled) {
                background-color: white;
                color: black;
            }
            #startMenu button.selected {
                background-color: #4CAF50;
                border-color: #4CAF50;
            }
            #startMenu button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }
            #mapButtons, #difficultyButtons {
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
                gap: 10px;
            }
        </style>
    </head>
    <body>
        <div id="info">
            Octree threejs demo - basic collisions with static triangle mesh<br />
            MOUSE to look around and to throw balls<br/>
            WASD to move and SPACE to jump
        </div>

        <div id="startMenu" class="overlay">
            <h1>Tiro ao Alvo</h1>
            <p style="margin-bottom: 10px;">1. Escolha o Mapa:</p>
            <div id="mapButtons">
                <button class="mapBtn" data-map-file="collision-world.glb">Arena Padrão</button>
                <button class="mapBtn" data-map-file="ice_scream_3_shopping_center_map.glb">Mapa 2</button>
            </div>

            <p style="margin-top: 25px; margin-bottom: 10px;">2. Escolha a Dificuldade:</p>
            <div id="difficultyButtons">
                <button class="diffBtn" data-difficulty="easy">Fácil (10)</button>
                <button class="diffBtn" data-difficulty="medium">Médio (20)</button>
                <button class="diffBtn" data-difficulty="hard">Difícil (35)</button>
            </div>
            
            <button id="startGameBtn" style="margin-top: 30px;" disabled>Iniciar Jogo</button>
        </div>

        <div id="hud">
            <div id="timer">Tempo: 60</div>
            <div id="score">Pontos: 0</div>
        </div>

        <div id="endScreen" class="overlay">
            <h1>Fim de Jogo!</h1>
            <p>Sua pontuação final: <span id="finalScore">0</span></p>
            <button id="restartButton">Voltar ao Menu</button>
        </div>

        <div id="crosshair">+</div>

        <div id="container"></div>

        <script type="importmap">
            {
                "imports": {
                    "three": "../build/three.module.js",
                    "three/addons/": "./jsm/"
                }
            }
        </script>

        <script type="module">
            // Imports (limpos)
            import * as THREE from 'three';
            import Stats from 'three/addons/libs/stats.module.js';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import { Octree } from 'three/addons/math/Octree.js';
            import { Capsule } from 'three/addons/math/Capsule.js';

            // Configuração da cena
            const clock = new THREE.Clock();
            const scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x88ccee );
            scene.fog = new THREE.Fog( 0x88ccee, 0, 150 );
            const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.rotation.order = 'YXZ';

            const listener = new THREE.AudioListener();
            camera.add( listener );

            const backgroundMusic = new THREE.Audio( listener );

            const audioLoader = new THREE.AudioLoader();

            audioLoader.load( './audio/Doom.mp3', function( buffer ) {
                backgroundMusic.setBuffer( buffer );
                backgroundMusic.setLoop( true ); // Define para tocar em loop
                backgroundMusic.setVolume( 0.3 ); // Define o volume (0.0 a 1.0)
    
    
                function startMusicOnFirstClick() {
                    if (!backgroundMusic.isPlaying) {
                    backgroundMusic.play();
                    }
                    document.removeEventListener('mousedown', startMusicOnFirstClick);
                }
    
    document.addEventListener('mousedown', startMusicOnFirstClick);
});

            // Iluminação Aprimorada
            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
            scene.add( ambientLight );

            const hemisphereLight = new THREE.HemisphereLight( 0x8dc1de, 0xb1957a, 1.5 );
            hemisphereLight.position.set( 2, 1, 1 );
            scene.add( hemisphereLight );

            const directionalLight = new THREE.DirectionalLight( 0xfffbe3, 3.0 );
            directionalLight.position.set( - 5, 25, - 1 );
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.01;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.left = - 30;
            directionalLight.shadow.camera.top    = 30;
            directionalLight.shadow.camera.bottom = - 30;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.radius = 4;
            directionalLight.shadow.bias = - 0.00006;
            scene.add( directionalLight );
            
            // Renderer e Stats
            const container = document.getElementById( 'container' );
            const renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;
            renderer.toneMapping = THREE.ACESFilFilmicToneMapping;
            container.appendChild( renderer.domElement );
            const stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            container.appendChild( stats.domElement );
            
            // Constantes e Variáveis Globais
            const GRAVITY = 30;
            const STEPS_PER_FRAME = 5;
            
            let gameState = 'MENU';
            let score = 0;
            let timeLeft = 60; 
            const targets = [];
            const targetMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const targetGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32);

            // Variáveis para seleção de mapa
            let currentMap = null;
            let selectedMapFile = null;
            let selectedDifficulty = null;
            const loader = new GLTFLoader().setPath( './models/gltf/' );

            const DIFFICULTIES = {
                easy: 10,
                medium: 20,
                hard: 35
            };
            
            // Referências aos elementos da interface
            const hudElement = document.getElementById('hud');
            const timerElement = document.getElementById( 'timer' );
            const scoreElement = document.getElementById( 'score' );
            const startMenuElement = document.getElementById('startMenu');
            const endScreenElement = document.getElementById( 'endScreen' );
            const finalScoreElement = document.getElementById( 'finalScore' );
            const restartButton = document.getElementById( 'restartButton' );
            const crosshairElement = document.getElementById('crosshair');

            // Novas referências de botões
            const mapButtons = document.querySelectorAll('.mapBtn');
            const difficultyButtons = document.querySelectorAll('.diffBtn');
            const startGameBtn = document.getElementById('startGameBtn');
            
            // Configuração das Esferas e Jogador
            const NUM_SPHERES = 100;
            const SPHERE_RADIUS = 0.2;
            const sphereGeometry = new THREE.IcosahedronGeometry( SPHERE_RADIUS, 5 );
            const sphereMaterial = new THREE.MeshLambertMaterial( { color: 0xdede8d } );
            const spheres = [];
            let sphereIdx = 0;
            for ( let i = 0; i < NUM_SPHERES; i ++ ) {
                const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                scene.add( sphere );
                spheres.push( {
                    mesh: sphere,
                    collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ),
                    velocity: new THREE.Vector3()
                } );
            }
            const worldOctree = new Octree();
            const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1.8, 0 ), 0.35 );
            const playerVelocity = new THREE.Vector3();
            const playerDirection = new THREE.Vector3();
            let playerOnFloor = false;
            let mouseTime = 0;
            const keyStates = {};
            const vector1 = new THREE.Vector3();
            const vector2 = new THREE.Vector3();
            const vector3 = new THREE.Vector3();

            // --- Funções de Alvo ---
            function clearTargets() {
                for (const target of targets) {
                    scene.remove(target.mesh);
                }
                targets.length = 0;
            }
            
            function createTargets(count, mapBox) {
                clearTargets();

                const mapSize = new THREE.Vector3();
                mapBox.getSize(mapSize);
                const mapCenter = new THREE.Vector3();
                mapBox.getCenter(mapCenter);

                const minX = mapCenter.x - (mapSize.x / 2) * 0.9;
                const maxX = mapCenter.x + (mapSize.x / 2) * 0.9;
                const minZ = mapCenter.z - (mapSize.z / 2) * 0.9;
                const maxZ = mapCenter.z + (mapSize.z / 2) * 0.9;
                const minY = mapBox.min.y + 1;
                const maxY = mapBox.min.y + (mapSize.y * 0.8);

                for (let i = 0; i < count; i++) {
                    const target = new THREE.Mesh(targetGeometry, targetMaterial);
                    target.castShadow = true;
                    target.receiveShadow = true;
                    
                    const px = THREE.MathUtils.randFloat(minX, maxX);
                    const py = THREE.MathUtils.randFloat(minY, maxY);
                    const pz = THREE.MathUtils.randFloat(minZ, maxZ);

                    target.position.set(px, py, pz);
                    target.rotation.x = Math.PI / 2;
                    scene.add(target);

                    targets.push({
                        mesh: target,
                        collider: new THREE.Sphere(target.position.clone(), 0.85),
                        active: true,
                    });
                }
            }

            // --- Eventos de Controle ---
            document.addEventListener( 'keydown', ( event ) => { keyStates[ event.code ] = true; } );
            document.addEventListener( 'keyup', ( event ) => { keyStates[ event.code ] = false; } );
            
            container.addEventListener( 'mousedown', () => {
                if (gameState === 'PLAYING') {
                    document.body.requestPointerLock();
                    mouseTime = performance.now();
                }
            } );

            document.addEventListener( 'mouseup', () => {
                if (gameState === 'PLAYING' && document.pointerLockElement) {
                     throwBall();
                }
            } );

            document.body.addEventListener( 'mousemove', ( event ) => {
                if ( document.pointerLockElement === document.body ) {
                    camera.rotation.y -= event.movementX / 500;
                    camera.rotation.x -= event.movementY / 500;
                }
            } );
            window.addEventListener( 'resize', onWindowResize );
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
            // --- Lógica do Novo Menu ---
            function checkStartButton() {
                if (selectedMapFile && selectedDifficulty) {
                    startGameBtn.disabled = false;
                    startGameBtn.innerText = 'Iniciar Jogo';
                } else {
                    startGameBtn.disabled = true;
                }
            }

            mapButtons.forEach(button => {
                button.addEventListener('click', () => {
                    mapButtons.forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                    selectedMapFile = button.dataset.mapFile;
                    checkStartButton();
                });
            });

            difficultyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                    selectedDifficulty = DIFFICULTIES[button.dataset.difficulty];
                    checkStartButton();
                });
            });

            startGameBtn.addEventListener('click', () => {
                if (selectedMapFile && selectedDifficulty) {
                    startGame(selectedMapFile, selectedDifficulty);
                    startGameBtn.disabled = true;
                    startGameBtn.innerText = 'Carregando...';
                }
            });

            restartButton.addEventListener('click', returnToMenu);

            // --- Funções de Física e Colisão ---
            function throwBall() {
                const sphere = spheres[ sphereIdx ];
                camera.getWorldDirection( playerDirection );
                sphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );
                const impulse = 15 + 30 * ( 1 - Math.exp( ( mouseTime - performance.now() ) * 0.001 ) );
                sphere.velocity.copy( playerDirection ).multiplyScalar( impulse );
                sphere.velocity.addScaledVector( playerVelocity, 2 );
                sphereIdx = ( sphereIdx + 1 ) % spheres.length;
            }

            function playerCollisions() {
                const result = worldOctree.capsuleIntersect( playerCollider );
                playerOnFloor = false;
                if ( result ) {
                    playerOnFloor = result.normal.y > 0;
                    if ( ! playerOnFloor ) {
                        playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
                    }
                    if ( result.depth >= 1e-10 ) {
                        playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
                    }
                }
            }

            function updatePlayer( deltaTime ) {
                let damping = Math.exp( - 4 * deltaTime ) - 1;
                if ( ! playerOnFloor ) {
                    playerVelocity.y -= GRAVITY * deltaTime;
                    damping *= 0.1;
                }
                playerVelocity.addScaledVector( playerVelocity, damping );
                const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
                playerCollider.translate( deltaPosition );
                playerCollisions();
                camera.position.copy( playerCollider.end );
            }

            function playerSphereCollision( sphere ) {
                const center = vector1.addVectors( playerCollider.start, playerCollider.end ).multiplyScalar( 0.5 );
                const sphere_center = sphere.collider.center;
                const r = playerCollider.radius + sphere.collider.radius;
                const r2 = r * r;
                for ( const point of [ playerCollider.start, playerCollider.end, center ] ) {
                    const d2 = point.distanceToSquared( sphere_center );
                    if ( d2 < r2 ) {
                        const normal = vector1.subVectors( point, sphere_center ).normalize();
                        const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( playerVelocity ) );
                        const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );
                        playerVelocity.add( v2 ).sub( v1 );
                        sphere.velocity.add( v1 ).sub( v2 );
                        const d = ( r - Math.sqrt( d2 ) ) / 2;
                        sphere_center.addScaledVector( normal, - d );
                    }
                }
            }

            function spheresCollisions() {
                for ( let i = 0, length = spheres.length; i < length; i ++ ) {
                    const s1 = spheres[ i ];
                    for ( let j = i + 1; j < length; j ++ ) {
                        const s2 = spheres[ j ];
                        const d2 = s1.collider.center.distanceToSquared( s2.collider.center );
                        const r = s1.collider.radius + s2.collider.radius;
                        const r2 = r * r;
                        if ( d2 < r2 ) {
                            const normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();
                            const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );
                            const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );
                            s1.velocity.add( v2 ).sub( v1 );
                            s2.velocity.add( v1 ).sub( v2 );
                            const d = ( r - Math.sqrt( d2 ) ) / 2;
                            s1.collider.center.addScaledVector( normal, d );
                            s2.collider.center.addScaledVector( normal, - d );
                        }
                    }
                }
            }
            
            function updateSpheres( deltaTime ) {
                spheres.forEach( sphere => {
                    sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );
                    const result = worldOctree.sphereIntersect( sphere.collider );
                    if ( result ) {
                        sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
                        sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );
                    } else {
                        sphere.velocity.y -= GRAVITY * deltaTime;
                    }
                    const damping = Math.exp( - 1.5 * deltaTime ) - 1;
                    sphere.velocity.addScaledVector( sphere.velocity, damping );
                    
                    if (gameState === 'PLAYING') {
                        for (const target of targets) {
                            if (target.active && sphere.collider.intersectsSphere(target.collider)) {
                                target.active = false;
                                target.mesh.visible = false;
                                score++;
                                scoreElement.innerText = `Pontos: ${score}`;
                                sphere.collider.center.set(0, -100, 0); 
                                sphere.velocity.set(0, 0, 0);
                                break;
                            }
                        }
                    }
                    playerSphereCollision( sphere );
                } );
                spheresCollisions();
                for ( const sphere of spheres ) {
                    sphere.mesh.position.copy( sphere.collider.center );
                }
            }
            
            // --- Funções de Vetor e Controle ---
            function getForwardVector() {
                camera.getWorldDirection( playerDirection );
                playerDirection.y = 0;
                playerDirection.normalize();
                return playerDirection;
            }

            function getSideVector() {
                camera.getWorldDirection( playerDirection );
                playerDirection.y = 0;
                playerDirection.normalize();
                playerDirection.cross( camera.up );
                return playerDirection;
            }

            function controls( deltaTime ) {
                if (gameState !== 'PLAYING') {
                    playerVelocity.x = 0;
                    playerVelocity.z = 0;
                    return;
                }
                const speedDelta = deltaTime * ( playerOnFloor ? 40 : 8 );
                if ( keyStates[ 'KeyW' ] ) playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
                if ( keyStates[ 'KeyS' ] ) playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );
                if ( keyStates[ 'KeyA' ] ) playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );
                if ( keyStates[ 'KeyD' ] ) playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
                if ( playerOnFloor && keyStates[ 'Space' ] ) playerVelocity.y = 15;
            }
            
            function teleportPlayerIfOob() {
                // Esta função agora só salva o jogador se ele cair DURANTE o jogo
                if ( camera.position.y <= -25 ) {
                    // Reseta para uma posição segura (0, 1, 0)
                    // (Poderia ser melhorado para usar o centro do mapa atual, mas isso funciona)
                    playerCollider.start.set( 0, 0.35, 0 );
                    playerCollider.end.set( 0, 2, 0 );
                    playerCollider.radius = 0.35;
                    camera.position.copy( playerCollider.end );
                    camera.rotation.set( 0, 0, 0 );
                }
            }
            
            // --- Funções de Estado do Jogo ---
            function startGame(mapFile, numTargets) {
                if (currentMap) {
                    scene.remove(currentMap);
                }
                worldOctree.clear(); 
                
                loader.load( mapFile, ( gltf ) => {
                    currentMap = gltf.scene;
                    scene.add( currentMap );

                    worldOctree.fromGraphNode( currentMap );

                    currentMap.traverse( child => {
                        if ( child.isMesh ) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            if ( child.material.map ) {
                                child.material.map.anisotropy = 4;
                            }
                        }
                    });

                    // Helper de debug removido
                    
                    const mapBox = new THREE.Box3().setFromObject(currentMap);
                    setupGameSession(numTargets, mapBox);
                });
            }

            // ### FUNÇÃO DE SPAWN ATUALIZADA ###
            function setupGameSession(numTargets, mapBox) {
                createTargets(numTargets, mapBox);
                
                score = 0;
                timeLeft = 60;
                scoreElement.innerText = `Pontos: 0`;
                timerElement.innerText = `Tempo: 60`;

                // Correção de Spawn:
                const mapCenter = new THREE.Vector3();
                mapBox.getCenter(mapCenter);
                const spawnHeadY = mapBox.min.y + 1.8;
                const spawnFeetY = mapBox.min.y + 0.35;

                playerCollider.start.set( mapCenter.x, spawnFeetY, mapCenter.z );
                playerCollider.end.set( mapCenter.x, spawnHeadY, mapCenter.z );
                playerCollider.radius = 0.35;
                
                camera.position.copy( playerCollider.end );
                camera.rotation.set( 0, 0, 0 );
                playerVelocity.set(0, 0, 0);

                // Inicia o jogo
                startMenuElement.style.display = 'none';
                endScreenElement.style.display = 'none';
                hudElement.style.display = 'block';
                crosshairElement.style.display = 'block';

                gameState = 'PLAYING';
                document.body.requestPointerLock();
                
                startGameBtn.disabled = true;
                startGameBtn.innerText = 'Iniciar Jogo';
            }

            function endGame() {
                gameState = 'ENDED';
                finalScoreElement.innerText = score;
                endScreenElement.style.display = 'flex';
                hudElement.style.display = 'none';
                crosshairElement.style.display = 'none';
                document.exitPointerLock();
            }

            function returnToMenu() {
                gameState = 'MENU';
                endScreenElement.style.display = 'none';
                startMenuElement.style.display = 'flex';
                crosshairElement.style.display = 'none';
                
                clearTargets();

                if (currentMap) {
                    scene.remove(currentMap);
                    currentMap = null;
                }
                worldOctree.clear();

                selectedMapFile = null;
                selectedDifficulty = null;
                mapButtons.forEach(btn => btn.classList.remove('selected'));
                difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                startGameBtn.disabled = true;
            }

            // --- Loop Principal (Animate) ---
            function animate() {
                const totalDeltaTime = Math.min( 0.05, clock.getDelta() );
                
                if (gameState === 'PLAYING') {
                    timeLeft -= totalDeltaTime;
                    timerElement.innerText = `Tempo: ${Math.max(0, Math.ceil(timeLeft))}`;
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }
                
                const deltaTime = totalDeltaTime / STEPS_PER_FRAME;
                
                for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
                    controls( deltaTime );
                    updatePlayer( deltaTime );
                    updateSpheres( deltaTime );
                    teleportPlayerIfOob();
                }
                
                renderer.render( scene, camera );
                stats.update();
            }
        </script>
    </body>
</html>